<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/77484950?s=400&u=7b0b92bf5587ea0595bbf9ce7c8191c20b63110c&v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="---

title: Shell （尚硅谷转载）

date: 2022-12-6 15:52:221

description: Shell编程基础入门

keywords: Shell

tags: Shell

categories: Shell

---

# 第1章 Shell概述

大数据程序员为什么要学习Shell呢？

1）需要看懂运维人员编写的Shell程序。">
<meta property="og:title" content="Shell ">
<meta property="og:description" content="---

title: Shell （尚硅谷转载）

date: 2022-12-6 15:52:221

description: Shell编程基础入门

keywords: Shell

tags: Shell

categories: Shell

---

# 第1章 Shell概述

大数据程序员为什么要学习Shell呢？

1）需要看懂运维人员编写的Shell程序。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhonghanlu.github.io/zhl.github.io/post/Shell%20.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/77484950?s=400&u=7b0b92bf5587ea0595bbf9ce7c8191c20b63110c&v=4">
<title>Shell </title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Shell </h1>
<div class="title-right">
    <a href="https://zhonghanlu.github.io/zhl.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/zhonghanlu/zhl.github.io/issues/3" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><hr>
<p>title: Shell （尚硅谷转载）</p>
<p>date: 2022-12-6 15:52:221</p>
<p>description: Shell编程基础入门</p>
<p>keywords: Shell</p>
<p>tags: Shell</p>
<p>categories: Shell</p>
<hr>
<h1>第1章 Shell概述</h1>
<p>大数据程序员为什么要学习Shell呢？</p>
<p>1）需要看懂运维人员编写的Shell程序。</p>
<p>2）偶尔会编写一些简单Shell程序来管理集群、提高开发效率。</p>
<h1>第2章 Shell解析器</h1>
<p>（1）Linux提供的Shell解析器有：</p>
<blockquote>
<p>[atguigu@hadoop101 ~]$ cat /etc/shells</p>
<p>/bin/sh</p>
<p>/bin/bash</p>
<p>/sbin/nologin</p>
<p>/bin/dash</p>
<p>/bin/tcsh</p>
<p>/bin/csh</p>
</blockquote>
<p>（2）bash和sh的关系</p>
<blockquote>
<p>[atguigu@hadoop101 bin]$ ll | grep bash</p>
<p>-rwxr-xr-x. 1 root root 941880 5月 11 2016 bash</p>
<p>lrwxrwxrwx. 1 root root 4 5月 27 2017 sh -&gt; bash</p>
</blockquote>
<p>（3）Centos默认的解析器是bash</p>
<blockquote>
<p>[atguigu@hadoop102 bin]$ echo $SHELL</p>
<p>/bin/bash</p>
</blockquote>
<h1>第3章 Shell脚本入门</h1>
<p>1．脚本格式</p>
<p>脚本以#!/bin/bash开头（指定解析器）</p>
<p>2．第一个Shell脚本：helloworld</p>
<p>（1）需求：创建一个Shell脚本，输出helloworld</p>
<p>（2）案例实操：</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch helloworld.sh</p>
<p>[atguigu@hadoop101 datas]$ vi helloworld.sh</p>
<p>在helloworld.sh中输入如下内容</p>
<p>#!/bin/bash</p>
<p>echo "helloworld"</p>
</blockquote>
<p>（3）脚本的常用执行方式</p>
<p>第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<p>sh+脚本的相对路径</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ sh helloworld.sh</p>
<p>Helloworld</p>
</blockquote>
<p>sh+脚本的绝对路径</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ sh /home/atguigu/datas/helloworld.sh</p>
<p>helloworld</p>
</blockquote>
<p>bash+脚本的相对路径</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ bash helloworld.sh</p>
<p>Helloworld</p>
</blockquote>
<p>bash+脚本的绝对路径</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ bash /home/atguigu/datas/helloworld.sh</p>
<p>Helloworld</p>
<p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p>
</blockquote>
<p>（a）首先要赋予helloworld.sh 脚本的+x权限</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ chmod 777 helloworld.sh</p>
</blockquote>
<p>（b）执行脚本</p>
<blockquote>
<p>相对路径</p>
<p>[atguigu@hadoop101 datas]$ ./helloworld.sh</p>
<p>Helloworld</p>
<p>绝对路径</p>
<p>[atguigu@hadoop101 datas]$ /home/atguigu/datas/helloworld.sh</p>
<p>Helloworld</p>
</blockquote>
<p>注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p>
<p>3．第二个Shell脚本：多命令处理</p>
<p>（1）需求：</p>
<blockquote>
<p>在/home/atguigu/目录下创建一个banzhang.txt,在banzhang.txt文件中增加"I<br>
love cls"。</p>
</blockquote>
<p>（2）案例实操：</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch batch.sh</p>
<p>[atguigu@hadoop101 datas]$ vi batch.sh</p>
<p>在batch.sh中输入如下内容</p>
<p>#!/bin/bash</p>
<p>cd /home/atguigu</p>
<p>touch cls.txt</p>
<p>echo "I love cls" &gt;&gt;cls.txt</p>
</blockquote>
<h1>第4章 Shell中的变量</h1>
<h2>4.1 系统变量</h2>
<p>1. 常用系统变量</p>
<p>$HOME、$PWD、$SHELL、$USER等</p>
<p>2．案例实操</p>
<p>（1）查看系统变量的值</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ echo $HOME</p>
<p>/home/atguigu</p>
</blockquote>
<p>（2）显示当前Shell中所有变量：set</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ set</p>
<p>BASH=/bin/bash</p>
<p>BASH_ALIASES=()</p>
<p>BASH_ARGC=()</p>
<p>BASH_ARGV=()</p>
</blockquote>
<h2>4.2 自定义变量</h2>
<p>1．基本语法</p>
<p>（1）定义变量：变量=值</p>
<p>（2）撤销变量：unset 变量</p>
<p>（3）声明静态变量：readonly变量，注意：不能unset</p>
<p>2．变量定义规则</p>
<p>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。</p>
<p>（2）等号两侧不能有空格</p>
<p>（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</p>
<p>（4）变量的值如果有空格，需要使用双引号或单引号括起来。</p>
<p>3．案例实操</p>
<p>（1）定义变量A</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ A=5</p>
<p>[atguigu@hadoop101 datas]$ echo $A</p>
<p>5</p>
</blockquote>
<p>（2）给变量A重新赋值</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ A=8</p>
<p>[atguigu@hadoop101 datas]$ echo $A</p>
<p>8</p>
</blockquote>
<p>（3）撤销变量A</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ unset A</p>
<p>[atguigu@hadoop101 datas]$ echo $A</p>
</blockquote>
<p>（4）声明静态的变量B=2，不能unset</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ readonly B=2</p>
<p>[atguigu@hadoop101 datas]$ echo $B</p>
<p>2</p>
<p>[atguigu@hadoop101 datas]$ B=9</p>
<p>-bash: B: readonly variable</p>
</blockquote>
<p>（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</p>
<blockquote>
<p>[atguigu@hadoop102 ~]$ C=1+2</p>
<p>[atguigu@hadoop102 ~]$ echo $C</p>
<p>1+2</p>
</blockquote>
<p>（6）变量的值如果有空格，需要使用双引号或单引号括起来</p>
<blockquote>
<p>[atguigu@hadoop102 ~]$ D=I love banzhang</p>
<p>-bash: world: command not found</p>
<p>[atguigu@hadoop102 ~]$ D="I love banzhang"</p>
<p>[atguigu@hadoop102 ~]$ echo $A</p>
<p>I love banzhang</p>
</blockquote>
<p>（7）可把变量提升为全局环境变量，可供其他Shell程序使用</p>
<blockquote>
<p>export 变量名</p>
<p>[atguigu@hadoop101 datas]$ vim helloworld.sh</p>
<p>在helloworld.sh文件中增加echo $B</p>
<p>#!/bin/bash</p>
<p>echo "helloworld"</p>
<p>echo $B</p>
<p>[atguigu@hadoop101 datas]$ ./helloworld.sh</p>
<p>Helloworld</p>
<p>发现并没有打印输出变量B的值。</p>
<p>[atguigu@hadoop101 datas]$ export B</p>
<p>[atguigu@hadoop101 datas]$ ./helloworld.sh</p>
<p>helloworld</p>
<p>2</p>
</blockquote>
<h2>4.3 特殊变量：$n</h2>
<p>1．基本语法</p>
<p>$n<br>
（功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）</p>
<p>2．案例实操</p>
<p>（1）输出该脚本文件名称、输入参数1和输入参数2 的值</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch parameter.sh</p>
<p>[atguigu@hadoop101 datas]$ vim parameter.sh</p>
<p>#!/bin/bash</p>
<p>echo "$0 $1 $2"</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 parameter.sh</p>
<p>[atguigu@hadoop101 datas]$ ./parameter.sh cls xz</p>
<p>./parameter.sh cls xz</p>
</blockquote>
<h2>4.4 特殊变量：$#</h2>
<p>1．基本语法</p>
<p>$# （功能描述：获取所有输入参数个数，常用于循环）。</p>
<p>2．案例实操</p>
<p>（1）获取输入参数的个数</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ vim parameter.sh</p>
<p>#!/bin/bash</p>
<p>echo "$0 $1 $2"</p>
<p>echo $#</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 parameter.sh</p>
<p>[atguigu@hadoop101 datas]$ ./parameter.sh cls xz</p>
<p>parameter.sh cls xz</p>
<p>2</p>
</blockquote>
<h2>4.5 特殊变量：$*、$@</h2>
<p>1．基本语法</p>
<p>$*<br>
（功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p>
<p>$@<br>
（功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</p>
<p>2．案例实操</p>
<p>（1）打印输入的所有参数</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ vim parameter.sh</p>
<p>#!/bin/bash</p>
<p>echo "$0 $1 $2"</p>
<p>echo $#</p>
<p>echo $*</p>
<p>echo $@</p>
<p>[atguigu@hadoop101 datas]$ bash parameter.sh 1 2 3</p>
<p>parameter.sh 1 2</p>
<p>3</p>
<p>1 2 3</p>
<p>1 2 3</p>
</blockquote>
<h2>4.6 特殊变量：$？</h2>
<p>1．基本语法</p>
<p>$？<br>
（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</p>
<p>2．案例实操</p>
<p>（1）判断helloworld.sh脚本是否正确执行</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ ./helloworld.sh</p>
<p>hello world</p>
<p>[atguigu@hadoop101 datas]$ echo $?</p>
<p>0</p>
</blockquote>
<h1>第5章 运算符</h1>
<p>1．基本语法</p>
<p>（1）"$((运算式))"或"$[运算式]"</p>
<p>（2）expr + , - , \*, /, % 加，减，乘，除，取余</p>
<blockquote>
<p>注意：expr运算符间要有空格</p>
</blockquote>
<p>2．案例实操：</p>
<p>（1）计算3+2的值</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ expr 2 + 3</p>
<p>5</p>
</blockquote>
<p>（2）计算3-2的值</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ expr 3 - 2</p>
<p>1</p>
</blockquote>
<p>（3）计算（2+3）X4的值</p>
<blockquote>
<p>（a）expr一步完成计算</p>
<p>[atguigu@hadoop101 datas]$ expr `expr 2 + 3` \* 4</p>
<p>20</p>
<p>（b）采用$[运算式]方式</p>
<p>[atguigu@hadoop101 datas]# S=$[(2+3)*4]</p>
<p>[atguigu@hadoop101 datas]# echo $S</p>
</blockquote>
<h1>第6章 条件判断</h1>
<p>1．基本语法</p>
<p>[ condition ]（注意condition前后要有空格）</p>
<p>注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。</p>
<p>2. 常用判断条件</p>
<blockquote>
<p>（1）两个整数之间比较</p>
<p>= 字符串比较</p>
<p>-lt 小于（less than） -le 小于等于（less equal）</p>
<p>-eq 等于（equal） -gt 大于（greater than）</p>
<p>-ge 大于等于（greater equal） -ne 不等于（Not equal）</p>
<p>（2）按照文件权限进行判断</p>
<p>-r 有读的权限（read） -w 有写的权限（write）</p>
<p>-x 有执行的权限（execute）</p>
<p>（3）按照文件类型进行判断</p>
<p>-f 文件存在并且是一个常规的文件（file）</p>
<p>-e 文件存在（existence） -d 文件存在并是一个目录（directory）</p>
</blockquote>
<p>3．案例实操</p>
<p>（1）23是否大于等于22</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ [ 23 -ge 22 ]</p>
<p>[atguigu@hadoop101 datas]$ echo $?</p>
<p>0</p>
</blockquote>
<p>（2）helloworld.sh是否具有写权限</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ [ -w helloworld.sh ]</p>
<p>[atguigu@hadoop101 datas]$ echo $?</p>
<p>0</p>
</blockquote>
<p>（3）/home/atguigu/cls.txt目录中的文件是否存在</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ [ -e /home/atguigu/cls.txt ]</p>
<p>[atguigu@hadoop101 datas]$ echo $?</p>
<p>1</p>
</blockquote>
<p>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，||<br>
表示上一条命令执行失败后，才执行下一条命令）</p>
<blockquote>
<p>[atguigu@hadoop101 ~]$ [ condition ] &amp;&amp; echo OK || echo notok</p>
<p>OK</p>
<p>[atguigu@hadoop101 datas]$ [ condition ] &amp;&amp; [ ] || echo notok</p>
<p>notok</p>
</blockquote>
<h1>第7章 流程控制（重点）</h1>
<h2>7.1 if 判断</h2>
<p>1．基本语法</p>
<blockquote>
<p>if [ 条件判断式 ];then</p>
<p>程序</p>
<p>fi</p>
<p>或者</p>
<p>if [ 条件判断式 ]</p>
<p>then</p>
<p>程序</p>
<p>fi</p>
</blockquote>
<p>注意事项：</p>
<p>（1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格</p>
<p>（2）if后要有空格</p>
<p>2．案例实操</p>
<p>（1）输入一个数字，如果是1，则输出banzhang zhen<br>
shuai，如果是2，则输出cls zhen mei，如果是其它，什么也不输出。</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch if.sh</p>
<p>[atguigu@hadoop101 datas]$ vim if.sh</p>
<p>#!/bin/bash</p>
<p>if [ $1 -eq "1" ]</p>
<p>then</p>
<p>echo "banzhang zhen shuai"</p>
<p>elif [ $1 -eq "2" ]</p>
<p>then</p>
<p>echo "cls zhen mei"</p>
<p>fi</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 if.sh</p>
<p>[atguigu@hadoop101 datas]$ ./if.sh 1</p>
<p>banzhang zhen shuai</p>
</blockquote>
<h2>7.2 case 语句</h2>
<p>1．基本语法</p>
<blockquote>
<p>case $变量名 in</p>
<p>"值1"）</p>
<p>如果变量的值等于值1，则执行程序1</p>
<p>;;</p>
<p>"值2"）</p>
<p>如果变量的值等于值2，则执行程序2</p>
<p>;;</p>
<p>...省略其他分支...</p>
<p>*）</p>
<p>如果变量的值都不是以上的值，则执行此程序</p>
<p>;;</p>
<p>esac</p>
<p>注意事项：</p>
</blockquote>
<ol>
<li>
<p>case行尾必须为单词"in"，每一个模式匹配必须以右括号"）"结束。</p>
</li>
<li>
<p>双分号"<strong>;;</strong>"表示命令序列结束，相当于java中的break。</p>
</li>
<li>
<p>最后的"*）"表示默认模式，相当于java中的default。</p>
</li>
</ol>
<p>2．案例实操</p>
<p>（1）输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch case.sh</p>
<p>[atguigu@hadoop101 datas]$ vim case.sh</p>
<p>!/bin/bash</p>
<p>case $1 in</p>
<p>"1")</p>
<p>echo "banzhang"</p>
<p>;;</p>
<p>"2")</p>
<p>echo "cls"</p>
<p>;;</p>
<p>*)</p>
<p>echo "renyao"</p>
<p>;;</p>
<p>esac</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 case.sh</p>
<p>[atguigu@hadoop101 datas]$ ./case.sh 1</p>
<p>1</p>
</blockquote>
<h2>7.3 for 循环</h2>
<p>1．基本语法1</p>
<p>for (( 初始值;循环控制条件;变量变化 ))</p>
<blockquote>
<p>do</p>
<p>程序</p>
<p>done</p>
</blockquote>
<p>2．案例实操</p>
<blockquote>
<p>（1）从1加到100</p>
<p>[atguigu@hadoop101 datas]$ touch for1.sh</p>
<p>[atguigu@hadoop101 datas]$ vim for1.sh</p>
<p>#!/bin/bash</p>
<p>s=0</p>
<p>for((i=0;i&lt;=100;i++))</p>
<p>do</p>
<p>s=$[$s+$i]</p>
<p>done</p>
<p>echo $s</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 for1.sh</p>
<p>[atguigu@hadoop101 datas]$ ./for1.sh</p>
<p>"5050"</p>
</blockquote>
<p>3．基本语法2</p>
<blockquote>
<p>for 变量 in 值1 值2 值3...</p>
<p>do</p>
<p>程序</p>
<p>done</p>
</blockquote>
<p>4．案例实操</p>
<p>（1）打印所有输入参数</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch for2.sh</p>
<p>[atguigu@hadoop101 datas]$ vim for2.sh</p>
<p>#!/bin/bash</p>
<p>#打印数字</p>
<p>for i in $*</p>
<p>do</p>
<p>echo "ban zhang love $i "</p>
<p>done</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 for2.sh</p>
<p>[atguigu@hadoop101 datas]$ bash for2.sh cls xz bd</p>
<p>ban zhang love cls</p>
<p>ban zhang love xz</p>
<p>ban zhang love bd</p>
</blockquote>
<p>（2）比较$*和$@区别</p>
<p>（a）$*和$@都表示传递给函数或脚本的所有参数，不被双引号""包含时，都以$1<br>
$2 ...$n的形式输出所有参数。</p>
<p>+-----------------------------------------------------------------------+<br>
| [atguigu@hadoop101 datas]$ touch for.sh                            |<br>
|                                                                       |<br>
| [atguigu@hadoop101 datas]$ vim for.sh                              |<br>
|                                                                       |<br>
| #!/bin/bash                                                           |<br>
|                                                                       |<br>
| for i in $*                                                         |<br>
|                                                                       |<br>
| do                                                                    |<br>
|                                                                       |<br>
| echo "ban zhang love $i "                                          |<br>
|                                                                       |<br>
| done                                                                  |<br>
|                                                                       |<br>
| for j in $@                                                          |<br>
|                                                                       |<br>
| do                                                                    |<br>
|                                                                       |<br>
| echo "ban zhang love $j"                                           |<br>
|                                                                       |<br>
| done                                                                  |<br>
|                                                                       |<br>
| [atguigu@hadoop101 datas]$ bash for.sh cls xz bd                   |<br>
|                                                                       |<br>
| ban zhang love cls                                                    |<br>
|                                                                       |<br>
| ban zhang love xz                                                     |<br>
|                                                                       |<br>
| ban zhang love bd                                                     |<br>
|                                                                       |<br>
| ban zhang love cls                                                    |<br>
|                                                                       |<br>
| ban zhang love xz                                                     |<br>
|                                                                       |<br>
| ban zhang love bd                                                     |<br>
+-----------------------------------------------------------------------+</p>
<p>（b）当它们被双引号""包含时，"$*"会将所有的参数作为一个整体，以"$1<br>
$2 ...$n"的形式输出所有参数；"$@"会将各个参数分开，以"$1"<br>
"$2"..."$n"的形式输出所有参数。</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ vim for.sh</p>
<p>#!/bin/bash</p>
<p>for i in "$*"</p>
<p>#$*中的所有参数看成是一个整体，所以这个for循环只会循环一次</p>
<p>do</p>
<p>echo "ban zhang love $i"</p>
<p>done</p>
<p>for j in "$@"</p>
<p>#$@中的每个参数都看成是独立的，所以"$@"中有几个参数，就会循环几次</p>
<p>do</p>
<p>echo "ban zhang love $j"</p>
<p>done</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 for.sh</p>
<p>[atguigu@hadoop101 datas]$ bash for.sh cls xz bd</p>
<p>ban zhang love cls xz bd</p>
<p>ban zhang love cls</p>
<p>ban zhang love xz</p>
<p>ban zhang love bd</p>
</blockquote>
<h2>7.4 while 循环</h2>
<p>1．基本语法</p>
<blockquote>
<p>while [ 条件判断式 ]</p>
<p>do</p>
<p>程序</p>
<p>done</p>
</blockquote>
<p>2．案例实操</p>
<p>（1）从1加到100</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch while.sh</p>
<p>[atguigu@hadoop101 datas]$ vim while.sh</p>
<p>#!/bin/bash</p>
<p>s=0</p>
<p>i=1</p>
<p>while [ $i -le 100 ]</p>
<p>do</p>
<p>s=$[$s+$i]</p>
<p>i=$[$i+1]</p>
<p>done</p>
<p>echo $s</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 while.sh</p>
<p>[atguigu@hadoop101 datas]$ ./while.sh</p>
<p>5050</p>
</blockquote>
<h1>第8章 read读取控制台输入</h1>
<p>1．基本语法</p>
<p>read(选项)(参数)</p>
<p>选项：</p>
<blockquote>
<p>-p：指定读取值时的提示符；</p>
<p>-t：指定读取值时等待的时间（秒）。</p>
<p>参数</p>
<p>变量：指定读取值的变量名</p>
</blockquote>
<p>2．案例实操</p>
<p>（1）提示7秒内，读取控制台输入的名称</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch read.sh</p>
<p>[atguigu@hadoop101 datas]$ vim read.sh</p>
<p>#!/bin/bash</p>
<p>read -t 7 -p "Enter your name in 7 seconds " NAME</p>
<p>echo $NAME</p>
<p>[atguigu@hadoop101 datas]$ ./read.sh</p>
<p>Enter your name in 7 seconds xiaoze</p>
<p>xiaoze</p>
</blockquote>
<h1>第9章 函数</h1>
<h2>9.1 系统函数</h2>
<p>1．basename基本语法</p>
<p>basename [string / pathname] [suffix]<br>
（功能描述：basename命令会删掉所有的前缀包括最后一个（'/'）字符，然后将字符串显示出来。</p>
<p>选项：</p>
<p>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p>
<p>2．案例实操</p>
<p>（1）截取该/home/atguigu/banzhang.txt路径的文件名称</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt</p>
<p>banzhang.txt</p>
<p>[atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt</p>
<p>banzhang</p>
</blockquote>
<p>3. dirname基本语法</p>
<p>dirname 文件绝对路径<br>
（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</p>
<p>4．案例实操</p>
<p>（1）获取banzhang.txt文件的路径</p>
<blockquote>
<p>[atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt</p>
<p>/home/atguigu</p>
</blockquote>
<h2>9.2 自定义函数</h2>
<p>1．基本语法</p>
<blockquote>
<p>[ function ] funname[()]</p>
<p>{</p>
<p>Action;</p>
<p>[return int;]</p>
<p>}</p>
<p>funname</p>
</blockquote>
<p>2．经验技巧</p>
<p>（1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。</p>
<p>（2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)</p>
<p>3．案例实操</p>
<p>（1）计算两个输入参数的和</p>
<blockquote>
<p>[atguigu@hadoop101 datas]$ touch fun.sh</p>
<p>[atguigu@hadoop101 datas]$ vim fun.sh</p>
<p>#!/bin/bash</p>
<p>function sum()</p>
<p>{</p>
<p>s=0</p>
<p>s=$[ $1 + $2 ]</p>
<p>echo "$s"</p>
<p>}</p>
<p>read -p "Please input the number1: " n1;</p>
<p>read -p "Please input the number2: " n2;</p>
<p>sum $n1 $n2;</p>
<p>[atguigu@hadoop101 datas]$ chmod 777 fun.sh</p>
<p>[atguigu@hadoop101 datas]$ ./fun.sh</p>
<p>Please input the number1: 2</p>
<p>Please input the number2: 5</p>
<p>7</p>
</blockquote>
<h1>第10章 Shell工具（重点）</h1>
<h2>10.1 cut</h2>
<p>cut的工作就是"剪"，具体的说就是在文件中负责剪切数据用的。cut<br>
命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p>
<p>1.基本用法</p>
<p>cut [选项参数] filename</p>
<p>说明：默认分隔符是制表符</p>
<p>2.选项参数说明</p>
<p>表1-55</p>
<hr>
<p>选项参数      功能</p>
<p>-f            列号，提取第几列</p>
<p>-d            分隔符，按照指定分隔符分割列</p>
<hr>
<p>3.案例实操</p>
<blockquote>
<p>（0）数据准备</p>
<p>[atguigu@hadoop101 datas]$ touch cut.txt</p>
<p>[atguigu@hadoop101 datas]$ vim cut.txt</p>
<p>dong shen</p>
<p>guan zhen</p>
<p>wo wo</p>
<p>lai lai</p>
<p>le le</p>
<p>（1）切割cut.txt第一列</p>
<p>[atguigu@hadoop101 datas]$ cut -d " " -f 1 cut.txt</p>
<p>dong</p>
<p>guan</p>
<p>wo</p>
<p>lai</p>
<p>le</p>
<p>（2）切割cut.txt第二、三列</p>
<p>[atguigu@hadoop101 datas]$ cut -d " " -f 2,3 cut.txt</p>
<p>shen</p>
<p>zhen</p>
<p>wo</p>
<p>lai</p>
<p>le</p>
<p>（3）在cut.txt文件中切割出guan</p>
<p>[atguigu@hadoop101 datas]$ cat cut.txt | grep "guan" | cut -d<br>
" " -f 1</p>
<p>guan</p>
<p>（4）选取系统PATH变量值，第2个"："开始后的所有路径：</p>
<p>[atguigu@hadoop101 datas]$ echo $PATH</p>
<p>/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</p>
<p>[atguigu@hadoop102 datas]$ echo $PATH | cut -d: -f 2-</p>
<p>/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</p>
<p>（5）切割ifconfig 后打印的IP地址</p>
<p>[atguigu@hadoop101 datas]$ ifconfig eth0 | grep "inet addr" |<br>
cut -d: -f 2 | cut -d" " -f1</p>
<p>192.168.1.102</p>
</blockquote>
<h2>10.2 sed</h2>
<p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为"模式空间"，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<ol>
<li>基本用法</li>
</ol>
<blockquote>
<p>sed [选项参数] 'command' filename</p>
</blockquote>
<ol start="2">
<li>选项参数说明</li>
</ol>
<p>表1-56</p>
<hr>
<p>选项参数      功能</p>
<p>-e            直接在指令列模式上进行sed的动作编辑。</p>
<hr>
<ol start="3">
<li>命令功能描述</li>
</ol>
<p>表1-57</p>
<hr>
<p>命令          功能描述</p>
<p><em>a</em>           新增，a的后面可以接字串，在下一行出现</p>
<p>d             删除</p>
<p>s             查找并替换</p>
<hr>
<ol start="4">
<li>案例实操</li>
</ol>
<p>（0）数据准备</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ touch sed.txt</p>
<p>[atguigu@hadoop102 datas]$ vim sed.txt</p>
<p>dong shen</p>
<p>guan zhen</p>
<p>wo wo</p>
<p>lai lai</p>
<p>le le</p>
</blockquote>
<p>（1）将"mei nv"这个单词插入到sed.txt第二行下，打印。</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ sed '2a mei nv' sed.txt</p>
<p>dong shen</p>
<p>guan zhen</p>
<p>mei nv</p>
<p>wo wo</p>
<p>lai lai</p>
<p>le le</p>
<p>[atguigu@hadoop102 datas]$ cat sed.txt</p>
<p>dong shen</p>
<p>guan zhen</p>
<p>wo wo</p>
<p>lai lai</p>
<p>le le</p>
<p>注意：文件并没有改变</p>
</blockquote>
<p>（2）删除sed.txt文件所有包含wo的行</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ sed '/wo/d' sed.txt</p>
<p>dong shen</p>
<p>guan zhen</p>
<p>lai lai</p>
<p>le le</p>
</blockquote>
<p>（3）将sed.txt文件中wo替换为ni</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ sed 's/wo/ni/g' sed.txt</p>
<p>dong shen</p>
<p>guan zhen</p>
<p>ni ni</p>
<p>lai lai</p>
<p>le le</p>
<p>注意：'g'表示global，全部替换</p>
<p>（4）将sed.txt文件中的第二行删除并将wo替换为ni</p>
<p>[atguigu@hadoop102 datas]$ sed -e '2d' -e 's/wo/ni/g' sed.txt</p>
<p>dong shen</p>
<p>ni ni</p>
<p>lai lai</p>
<p>le le</p>
</blockquote>
<h2>10.3 awk</h2>
<p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p>
<ol>
<li>基本用法</li>
</ol>
<blockquote>
<p>awk [选项参数] 'pattern1{action1} pattern2{action2}...' filename</p>
<p>pattern：表示AWK在数据中查找的内容，就是匹配模式</p>
<p>action：在找到匹配内容时所执行的一系列命令</p>
</blockquote>
<ol start="2">
<li>选项参数说明</li>
</ol>
<p>表1-55</p>
<hr>
<p>选项参数      功能</p>
<p>-F            指定输入文件折分隔符</p>
<p>-v            赋值一个用户定义变量</p>
<hr>
<ol start="3">
<li>案例实操</li>
</ol>
<blockquote>
<p>（0）数据准备</p>
<p>[atguigu@hadoop102 datas]$ sudo cp /etc/passwd ./</p>
</blockquote>
<p>（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ awk -F: '/^root/{print $7}' passwd</p>
<p>/bin/bash</p>
</blockquote>
<p>（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以"，"号分割。</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ awk -F: '/^root/{print $1","$7}'<br>
passwd</p>
<p>root,/bin/bash</p>
<p>注意：只有匹配了pattern的行才会执行action</p>
</blockquote>
<p>（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加"dahaige，/bin/zuishuai"。</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ awk -F : 'BEGIN{print "user, shell"}<br>
{print $1","$7} END{print "dahaige,/bin/zuishuai"}' passwd</p>
<p>user, shell</p>
<p>root,/bin/bash</p>
<p>bin,/sbin/nologin</p>
<p>。。。</p>
<p>atguigu,/bin/bash</p>
<p>dahaige,/bin/zuishuai</p>
<p>注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p>
</blockquote>
<p>（4）将passwd文件中的用户id增加数值1并输出</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ awk -v i=1 -F: '{print $3+i}' passwd</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
</blockquote>
<ol start="4">
<li>awk的内置变量</li>
</ol>
<blockquote>
<p>表1-56</p>
</blockquote>
<hr>
<p>变量          说明</p>
<p>FILENAME      文件名</p>
<p>NR            已读的记录数</p>
<p>NF            浏览记录的域的个数（切割后，列的个数）</p>
<hr>
<ol start="5">
<li>案例实操</li>
</ol>
<blockquote>
<p>（1）统计passwd文件名，每行的行号，每行的列数</p>
<p>[atguigu@hadoop102 datas]$ awk -F: '{print "filename:" FILENAME<br>
", linenumber:" NR ",columns:" NF}' passwd</p>
<p>filename:passwd, linenumber:1,columns:7</p>
<p>filename:passwd, linenumber:2,columns:7</p>
<p>filename:passwd, linenumber:3,columns:7</p>
</blockquote>
<p>（2）切割IP</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ ifconfig eth0 | grep "inet addr" |<br>
awk -F: '{print $2}' | awk -F " " '{print $1}'</p>
<p>192.168.1.102</p>
</blockquote>
<p>（3）查询sed.txt中空行所在的行号</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ awk '/^$/{print NR}' sed.txt</p>
<p>5</p>
</blockquote>
<h2>10.4 sort</h2>
<p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p>
<ol>
<li>基本语法</li>
</ol>
<blockquote>
<p>sort(选项)(参数)</p>
<p>表1-57</p>
</blockquote>
<hr>
<p>选项          说明</p>
<p>-n            依照数值的大小排序</p>
<p>-r            以相反的顺序来排序</p>
<p>-t            设置排序时所用的分隔字符</p>
<p>-k            指定需要排序的列</p>
<hr>
<blockquote>
<p>参数：指定待排序的文件列表</p>
</blockquote>
<p>2. 案例实操</p>
<blockquote>
<p>（0）数据准备</p>
<p>[atguigu@hadoop102 datas]$ touch sort.sh</p>
<p>[atguigu@hadoop102 datas]$ vim sort.sh</p>
<p>bb:40:5.4</p>
<p>bd:20:4.2</p>
<p>xz:50:2.3</p>
<p>cls:10:3.5</p>
<p>ss:30:1.6</p>
<p>（1）按照"："分割后的第三列倒序排序。</p>
<p>[atguigu@hadoop102 datas]$ sort -t : -nrk 3 sort.sh</p>
<p>bb:40:5.4</p>
<p>bd:20:4.2</p>
<p>cls:10:3.5</p>
<p>xz:50:2.3</p>
<p>ss:30:1.6</p>
</blockquote>
<h1>第11章 企业真实面试题（重点）</h1>
<h2>11.1 京东</h2>
<blockquote>
<p>问题1：使用Linux命令查询file1中空行所在的行号</p>
<p>答案：</p>
<p>[atguigu@hadoop102 datas]$ awk '/^$/{print NR}' sed.txt</p>
<p>5</p>
<p>问题2：有文件chengji.txt内容如下:</p>
<p>张三 40</p>
<p>李四 50</p>
<p>王五 60</p>
</blockquote>
<p>使用Linux命令计算第二列的和并输出</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ cat chengji.txt | awk -F " "<br>
'{sum+=$2} END{print sum}'</p>
<p>150</p>
</blockquote>
<h2>11.2 搜狐&amp;和讯网</h2>
<p>问题1：Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？</p>
<blockquote>
<p>#!/bin/bash</p>
<p>if [ -f file.txt ]; then</p>
<p>echo "文件存在!"</p>
<p>else</p>
<p>echo "文件不存在!"</p>
<p>fi</p>
</blockquote>
<h2>11.3 新浪</h2>
<p>问题1：用shell写一个脚本，对文本中无序的一列数字排序</p>
<blockquote>
<p>[root@CentOS6-2 ~]# cat test.txt</p>
<p>9</p>
<p>8</p>
<p>7</p>
<p>6</p>
<p>5</p>
<p>4</p>
<p>3</p>
<p>2</p>
<p>10</p>
<p>1</p>
<p>[root@CentOS6-2 ~]# sort -n test.txt|awk '{a+=$0;print<br>
$0}END{print "SUM="a}'</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>SUM=55</p>
</blockquote>
<h2>11.3 金和网络</h2>
<p>问题1：请用shell脚本写出查找当前文件夹（/home）下所有的文本文件内容中包含有字符"shen"的文件名称</p>
<blockquote>
<p>[atguigu@hadoop102 datas]$ grep -r "shen" /home | cut -d ":"<br>
-f 1</p>
<p>/home/atguigu/datas/sed.txt</p>
<p>/home/atguigu/datas/cut.txt</p>
</blockquote></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://zhonghanlu.github.io/zhl.github.io">Zhong Hanlu's blog</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","zhonghanlu/zhl.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>


</html>
